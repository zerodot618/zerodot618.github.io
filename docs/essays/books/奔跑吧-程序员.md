# 奔跑吧，程序员

## 产品篇

大公司就像经典力学，面对的大都是可预见以及有确定的规则的环境下低速运转，而创业公司就像量子力学，如微观粒子基于某些不可预知、非确定的规则的环境下高速运转。我们不应只知道经典力学和大公司，我们也要了解量子力学和创业公司，如此我们才能看清世界的全貌。

### 什么是创业？

什么是科技创业公司？科技创业公司不同于一家业已成熟的公司，因为其产品已经得到市场的充分认可；甚至不同于街道边一家新开的餐饮店，因为其不提供技术。

一家真正的科技创业公司，**进行的是技术研发（产品）,环境总处于变化之中，主要目标是为了增长，组织运作模式是以探索的模式在运行**。

**应该加入创业公司的理由**

在科技创业工作，甚至自己创立这样一家公司，要考虑三个主要因素：**更多的机会、更多的所有权以及更多的乐趣**。

更多的机会。软件正在改变世界，也蚕食着世界。很多的开源项目能让我们节省开发时间，开发的产品质量也更高。很多的服务、分布式的协作工具也可供我们付费使用。而且关于成功创业的信息也是无处不在，获取风投资金的渠道也越来越多。这一切意味着我们正处于历史上一个不同寻常的时间，是一场史无前例的科技盛宴，为了影响数以万计的人的生活，我们有加入的理由。

更多的所有权。在大公司里也不意味着就拿着了金饭碗，依旧面临被裁员的风险，相比于以前，工作稳定性已然不复存在。总的说来，在大公司就相当于一艘大全，你就是一个水手，假面面前是一座冰山，任凭你的努力是不可能改变航向的。而在小公司，对自己想做什么有**自主权**（话语权）,与公司的关系让人觉得更加有**使命感**，面对各种任务也能体现自身的**掌控力**。

更多的乐趣。在大公司，几乎就是按部就班，优化产品，而在创业公司，则就是走上一条探索之路，其乐无穷。

**不应该加入创业公司的理由**

创业公司也不是集有点于一身的家伙，它也是有很多弊端的。首先，创业的失败风险机率是很高的，统计的数据 75%；其次，加入创业公司，你要牺牲你个人的时间、陪伴家人的时间；再者，创业是异常艰辛的，除了花费脑力（技术），还得花费体力（管理）。所以，结合自身的考虑才是王道。

### 如何想出创业点子？

创造力是一项可以学习的技能，而不是二元论——要么拥有，要么没有。人与人之分，也只是擅长的程度不一。

**点子何处来？** 点子也不是灵光一现，而是一个发展和进化的过程。物理学的能力守恒定律阐述了能量从来不会凭空产生或湮灭，而是以不同的形式被重新利用，点子也同样遵守这样的守恒定律，所有的新的想法只不过是现有想法组合而成的结果。

创造力的产生可以归结为三个阶段：1、模仿；2、转换；3、合并。正如牛顿曾说的“站在巨人的肩膀上。”

所以，如果我们想要寻找创业的好点子，就需要一整堆的“原料”，从而可以在此基础上研究、注明出处、重新合成、聚合和转换。而这时需要知识的支撑。

对于知识无需多言，知识是利滚利的，越早投资越好。我们都要力争知识的宽度与广度，这最好的策略就是努力成为一名**T 型人**（专才通才兼具）。只要能很好地把知识的深度和广度结合起来，就可以把知识转变为点子。

点子的产生我们很难阐述清楚，因而也才有了创新思维这一说。它就像我们强行控制的潜意思，但可以训练和引导它。我们可以通过以下并不仅限的方法或者说是营造一个环境来我们我们产生新的点子？

- 给自己充足的时间；（点子是一个发展和进化的过程）
- 记录点子日记；（无论好坏的点击尽管记下来）
- 解决问题；（有意识地去思考相关主题）
- 放下工作；（放松，从而让潜意识去解决问题）
- 添加约束；（减少选项，提高相处创造性解决方案的能力）
- 寻找痛点；（说清楚问题等于解决了问题的一半）
- 与他人交谈。 （口头表述也是创新的强有力手段）

分享一个创业点子列表（[http://www.hello-startup.net/resources/startup-ideas](http://www.hello-startup.net/resources/startup-ideas)），侧面说明，点子是不怕别人知道的。

**验证点子是否值得转化为产品**。一个好的策略就是“快速制胜（频率制胜）”，其目的就是把发聩回路变短。在产品开发中比较推崇“敏捷/精益方法”也是这个道理。

更快的反馈回路可以改善（提高）你的价值曲线：比起要持续五年投钱才能知道行不行的项目，那些一个月后情况就已经清楚的项目更容易吸引别人投钱进去。快的反馈回路也可以改善你的代码：五分钟前才引入并且被自动化测试立即发现的 bug，和五个月前引入并且是由于顾客抱怨才发现的 bug 相比，前者的修复成本更低，修复可行性也更高。

大部分想法都是不可行的，大部分的假设都是错误的，我们经常要和时间赛跑，产品十有八九是失败的。虽然胜出的概率不大，但是有一些方法可以提高这一概率，那就是**客户开发**。

那么，如何找到客户并与之对话呢？可以分解为以下三个连续的阶段。

1. 验证问题

   确保找出客户实际面临并且痛苦到愿意掏腰包去解决的问题。

2. 验证 MVP

   实现潜在解决方案的最简可行产品（minimum viable product, MVP），让少量客户购买该产品进行验证。

3. 验证产品

   把 MVP 完善为完整的产品，让更多客户去购买，对可扩大化的商业模式进行验证。

对于你找出的问题，验证它是否大到有必要建立一家创业公司去解决，在思考问题的大小时，有三个方面需要考虑：频率、密度和痛苦程度。

- 频率：你所解决的问题经常发生吗？
- 密度：有很多人都会面临这个问题吗？
- 痛苦程度：该问题只是让人讨厌，还是绝对必须解决？

想要知道自己的点子在市场上的现在，则需要学会评估市场的规模。下面，列出的是评估市场规模的几种方法。

- 广告：利用广告目标分析工具，国内可以看看百度，腾讯相关的分析工具。
- 竞争：产看竞品产品，即使有人在做也无伤大雅。分析他们的好与坏，力争自己能做到人无我有，人有我优。
- 社区：在社区网站上搜索别人的讨论。国内主要是知乎。
- 市场研究和报告：试着在网上搜索探讨你所关注主题的报纸、图书、期刊、课程、广播和博客。或者去一些专业做行业数据收集分析调差的网站。
- 产品数据：如果产品已经面世，我们可以收集到许多数据并进行分析，对产品新特性的影响进行评估。

### 如何产品设计？

设计是冰山的秘密，人们看到的只有 10%。

设计关乎产品如何使用。想想为什么人们都会不由自主地认为 iPhone 好于 Android。生活处处有设计，每个人也时时刻刻都会用到设计，你的个人主页，简历，家庭装修，都是要用到设计方面的知识。只是因为我们缺少设计方面的训练，总认为设计和美术方面的能力只能是天生的。

设计是一个迭代的过程，就像绘画一样，要构思，要构草图，要精心描绘，要上色。目的就是向人们传达有价值的东西。而这也需要理解用户开始——以用户为中心的设计。

对于开发，设计就是产品，从产品开发的第一天起，它就应该是其中的一部分。以用户为中心的设计应该纳入我们的产品开发过程中，下面是他的五个基本原则：

- 用户故事：简短描述将要做的东西。回答用户是谁？他们要实现什么？他们为什么需要？这三个问题。把你的产品点子从脑海中短暂、模糊的想法转变成纸面上具体的文字和图示，这样可以暴露出你在问题理解上存在的一些缺陷。而这比修改已经编写好了成千上万行代码的成本低很多。
- 人物角色：代表使用你的产品的一个有特定目标、性格和要求的真正用户。不要试图去关注“平均用户”，人平均下来就是不洋不土、不男不女，如果你为平均的每个人做设计，那么谁都不会喜欢你设计出的东西。
- 情感设计：设计的情感因素对用户而言就像功能因素一样重要。例如常见的 404 页面，你是否体会到情感因素的作用？所以，在开发中，要为用户考虑周到，要积极响应用户，要宽容用户。
- 简单：牛顿说过：“真理往往都是存在于简单之中，而不是在纷杂与混乱之中。设计需要简单并不是因为简单更优美，而是因为人的记忆在同一时间只能处理少数几件事。如果设计中塞入太多东西，很快就会超出人的记忆局限，用户会觉得产品功能过多而无法使用。这就是我们为什么必须限制所有设计的信息数量（更少的文本、更少的按钮、更少的设置）和所有产品的功能数量的原因。
- 可用性测试：在用户使用你的产品时观察他们。

每个人都应该具备的基本的视觉设计技能和技术分别如下：

- 文案：知道如何提炼出清晰的信息去介绍你的动因、你的使命，是各种事情成功的关键因素之一。
- 设计重用：好的艺术家模仿，伟大的艺术家偷窃。开始每一个项目的时候，先浏览现有的设计，了解有哪些可以重用或哪些是自己需要的。
- 布局：布局有一个要点就是**亲密性**，元素之间的亲近程度表明它们在逻辑上是否相关联。逻辑上联系在一起的元素应该更加接近，没有关联的元素则应该远离一些。布局的另一个关键因素是**对齐**。对齐可以表达元素之间存在一种关系，且不需要让它们更接近或者离得更远（即实现亲近的要求），只要把它们沿着共同的线排放即可。
- 排版：排版就是安排文本的艺术与科学，目的是让文本易读和美观。排版最重要的几个因素：
  - 行宽：每一行的长度。（70 个字符并且两端对齐）
  - 行距：行与行之间的垂直间距。和行宽一样，如果行距设置得太小或太大，文本的阅读都会比较困难。行距的最佳尺寸一般都是字体尺寸的 120%～ 145%。
  - 字型、样式：字体的设计。
- 对比与重复：**对比**可以明显地区分设计中的两个部分。**重复**可以增长风格。
- 颜色：第一个窍门就是先用黑白图进行设计，然后再添加颜色。也就是说，先准备好文字材料、布局和排版，不给设计作品添加颜色。第二个技巧就是使用专业人士提供的调色板，而不是靠自己去想。

### 如何数据驱动与营销?

**数据**就是如何把一些假设和猜测转变为具体、可操作的行为。

正如评价一个球员的好坏，我们会分析他过往的比赛数据来给予他评级。同样的，成功的创业公司，我们也需要收集产品的相关数据，来分析产品的好坏。

这里，有几种类型的指标是所有公司都需要跟踪的：

- 获取（acquisition）：分析不同渠道来的用户，以分析渠道可不可行。
- 激活（activation）：这是测量有多少用户被你的产品所吸引，进行了账号注册、邀请朋友、执行搜索或者支付等动作。（例子：深度的 A/B 测试）
- 留存（retention）：让激活的用户回来并再次使用你的产品。在某种程度上，这也是一种获取，但是用户的留存通常利用的是不同的渠道，所以应该分别进行跟踪。还要跟踪在一个星期、一个月和一年之后有多少访问者会回来。
- 推荐（referral）：在产品现有用户的帮助下获取新的用户。
- 收益（revenue）：用你的收益数字去计算客户生命周期价值（customer lifetime value, CLV），这是估量一个客户在与你产生关系的整个生命周期中，你可以从他身上赚到多少钱的方法。另外，也别忘记根据其他指标对我们的收益数值进行分解。
- 神奇数字（the magic number）：找出你的神奇数字，就可以让你的团队关注一个清晰、具体、容易测量的目标，简化公司的决策制定。对于一个项目，我们可以看看它是否会显著影响我们的神奇数字。如果是的话，就进行；不是的话，先放一放再说。

**营销**就是如何让用户找到你的产品。现在并不是最出色的产品胜出，而是客户认为最出色的产品胜出。让客户觉察到你的产品并且影响他们对产品的感知，这就是所谓的营销。

创业公司最常见的 4 种营销渠道：

- 口口相传：只有做出更好的产品；提供出色的客户服务；让产品进入病毒式循环，才可以让人口口相传。
- 市场推广：广告、公告关系及媒体、email、SEO、社交媒体、集客式营销等。
- 销售：和客户达成交易，让客户购买（从用户处获取收益）。
- 品牌化：最出色的产品胜出，而是客户认为最出色的产品胜出。客户如何看待你的公司——如果他们想到的是你的品牌，那么尝试对这种感知进行影响的行为就称为品牌化。

## 技术篇

### 如何选择技术栈?

**选择技术栈的黄金法则——好的技术栈的扩展要快于需要进行的维护**。
技术栈就是工具，它是实现产品的手段，不是产品的终结，也不是产品本身。不要因为某项技术听起来很酷或者很有趣就选择它，我们选择一种技术是因为它可以为我所用。

我们的目标就是要能够对技术栈进行扩展——以支持更多用户、更多流量、更多数据和更多代码——通过投入资金和硬件，而不是投入人力，来解决问题。

选择技术栈，情景至关重要。而这情景包括我们考虑的产品类型、团队和公司文化等等方面。

如何为创业公司选择初始的技术栈？只用一句话来回答就是：熟悉什么就用什么。

作为创业公司，有些技术一定永远不要自己去实现。下面列出了部分这样的技术。

- 安全：加密、密码存储、信用卡存储。
- Web 技术：HTTP 服务器、服务器端和客户端框架。
- 数据系统：数据库、NoSQL 存储、缓存、消息队列。
- 软件分发：版本控制、构建系统、自动化部署。
- 计算机科学：基本数据结果（映射、列表、集）、排序算法。
- 处理通用数据格式的库：XML、HTML、CSV、JSON、URLs。
- 实用库：日期/时间操作、字符串操作、日志记录。
- 操作系统。
- 编程语言。

所有，对创业公司来说，使用开源产品通常是最好的选择，其次就是使用商业产品。内部实现基础框架应该被看作是最后的选择，只有在没有其他选择的时候才可以用。

**编程语言的选择**。主要是编程范式的不同，包括：面向对象编程、函数式编程、静态类型和自动内存管理。理论上来说，所有现代编程语言都是图灵完备的，所以它们都是等价的。在实践中，一些编程语言解决起某些类型的问题，比用其他语言更方便。通常，当应用出现过量负载，垃圾回收和并发性是编程语言最常见的两个性能瓶颈。

**服务器端框架的选择**。选择库还是框架通常都不是问题，问题是选择**最精简的框架**还是选择**全栈框架**，最好的选择通常就是模块化的全栈框架。

**数据库的选择**。对于许多创业公司而言，在应用程序规模较小、性能需求较低的时候，使用 ORM 是值得的，它可以正常满足 80%～ 90%的用户需求。重要的是要认识到，使用 ORM 并不意味着可以忽略关系型数据库底层的工作细节。我们仍然需要弄清楚关系型数据的建模、规范化、索引、链接和查询调优等知识，这样才能知道如何正确地存储数据，并满足 ORM 难以实现的那 10%～ 20%的用户需求。

一旦数据存储从单台服务器走向多台服务器，就会涉及分布式系统。所有的分布式系统都受到 CAP 定理的约束，该定理表述如下。一个分布式系统不可能同时满足以下三点：

- 一致性[Consistency]（所有节点能够同时访问同一份数据）；
- 可用性[Availability]（保证每一个请求都会接收到成功或失败的响应）；
- 分区容忍性[Partition Tolerance]（系统一部分出现任意信息丢失或故障时，系统仍能继续工作）。

在一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）中，只能择其二。在实践中，总是会有服务器故障或网络丢失信息的情况，所以所有的分布式系统必须选择 P——也就是说，不可能牺牲分区容忍性。所以实际的问题就成了，当存在网络分区的时候，是要坚持一致性还是坚持可用性？

实现可水平扩展的分布式数据系统有两个主要策略，即复制和分区。通过复制实现可扩展性有两种常用的方法，即**主-从复制**和**多主复制**。合适的分区策略，有两种主要的策略可供选择：**垂直分区**和**水平分区**。

数据库优化，最常见的选择：

- 对数据存储格式和现有数据库的查询进行优化；
- 在数据库之前设置缓存（例如内存缓存）；
- 建立主-从复制；
- 对无关联的表进行垂直分区；
- 对单张表进行水平分区；
- 建立多主复制。

一般而言，我们要尽可能避免对数据进行分区，并坚持使用单点写入。分片的多主系统存在更多的故障模式，在实现 JOIN 操作、事务、强制完整性约束、迁移、更新、备份和 id 生成方面也会更加复杂。NoSQL 的问题则是，你不得不在上述各个方面做出牺牲，即便大多数用户场景对于这一切并不是必要的。而即便在确有必要做出牺牲的情况下，用关系型数据库去实现也可以让我们走得很远。

### 如何整洁代码

所谓整洁的代码，是指代码专为人的理解而优化。原则如下

- **统一的代码布局**

  合理缩进，代码的结构就能初步显现。

- **命名**

  好的名称应该能回答所有的重要问题，应该精确、全面，能够揭示意图，并且遵循约定。

- **错误处理**

  每一个程序都有不同的错误处理需求，但是不应该是静静地吞下各种错误。如果遇到了任何类型的错误，就应该让整个转换过程明显地抛出失败信息。

- **不要重复自己(DRY)**

  如果发现自己在一次次地编写相同的代码，或者只是做一小点改变就会涉及代码库中的一半内容，那么就要想想办法让代码变得更加 DRY。特别当我们必须一次次地重复相同的**过程**，那么就需要实现一种自动化的过程；如果不只在一个地方有相同的**逻辑**，那么就需要实现抽象，以便共享单一的实现。

  重新发明轮子是最常见和不必要的重复，只要有可能，就应该使用开源库去代替。

- **单一职责原则(SRP)**

  规定了每一个类、函数和变量都应该只有一个单一的目的。所以要学会依据此合理拆分类、函数。

  遵循单一职责原则会使设计出现许多短小的、简单的、独立的函数，每个函数都容易阅读、维护和测试。

- **函数式编程**

  遵循单一职责原则会使设计出现许多短小的、简单的、独立的函数，每个函数都容易阅读、维护和测试。而且，我们还可以把这些函数中的几个组合在一起，创建具有更复杂行为的函数，这就是函数式编程的基本原理：使用函数和函数的组合作为应用程序的构建块。其中的关键就是用一种安全且容易组合的方式去设计函数。

- **松耦合**

  在软件领域，两个模块相互之间的依赖程度称为**耦合**。如果无论什么时候更新一个模块，都不得不频繁地更新另一个模块，这些模块就是**紧耦合**的，这通常表明代码是脆弱而且难以维护的。整洁的代码应该遵循**依赖反转原则**。

- **高内聚**

  所有的变量和方法都应该是有关联的，一切都应该在同一抽象层次上操作，每一部分都应该很好地相互配合。

- **注释**

  代码本身应该告诉你需要知道的几乎一切。如果代码没有做到，在你费劲地编写任何注释之前，应该先对代码进行改进。

  如果有代码本身无法体现的内容，才需要进行解释。

- **重构**

  重构是改变代码结构而没有改变其外部行为的过程，这是一种只影响软件“非功能”方面的编码任务：从外部看，代码实现的功能并没有变化；但从内部看，我们已经改进了它的设计。

### 如何具备可扩展性

**编程上的扩展性**。需要应对不断增长的代码库，这里有 4 个重要的编程实践：

- **自动化测试**

  自动化测试会给你做出修改的自信，自动化测试具备了迭代式的代码测试循环的优势，我们只需要运行一条测试命令，就能够快速得到正常与否的反馈。

- **代码分离**

  将代码分离成多个“片段”。通过这种方式，我们可以一次只考虑一个片段，并可以放心忽略其他片段。这就是所谓的抽象。一个出色的抽象应该满足两个属性：信息隐藏和可组合性。**信息隐藏**意味着抽象应该比其背后的细节更加简单，就像脑海中的图像要比真正的水果更加简单。**可组合性**意味着可以把多个抽象组合起来，从而得到新的抽象，这一抽象反过来也仍然能够和其他抽象组合。

- **代码评审**

  设计评审和代码评审可以捕捉到 55%～ 60%的 bug。代码评审还有另一个重要的好处：它们是在整个团队间传播知识、文化、培训以及所有权感的一种高效机制。

- **文档**

  文档对于代码规模的扩展和开发团队都是必不可少的，即便团队只有一个人也是如此。

**性能上的扩展**。只有在产品已经有了一定规模，性能可能成为瓶颈之后，这才是个需要考虑的问题。

性能调优的第一个步骤永远都是测量。我们必须用工具对代码进行测量，既要使用监控工具，也要使用性能工具和分析工具。

提供一份改进性能和可扩展性的最常见的高级策略列表。

- **分治**: 把一个问题划分成许多更小的问题
- **缓存**: 提前执行任务并保存结果，这样就不用在需要的时候再计算，只需要从存储中获取提前计算好的值即可
- **懒惰**: 除非绝对必要，否则可以先推迟一些任务，例如延迟加载网页的部分内容、只在滚动到该区域之后再加载、数据库中的乐观锁定。
- **近似正确性**：在许多情况下，得到一个“足够接近”的答案比得到准确的答案能减少很多工作量，例如最终一致性、HyperLogLog、降低持久性保证、尽力消息传递（best-effort messaging）。
- **异步**：在等待计算结果的时候不采用锁定或阻塞的方法，而是继续执行任务，在计算完成的时候再通知你，例如非阻塞I/O、事件循环、无锁数据结构。
- **抖动与随机化**：尝试将负载均匀扩散开，从而避免出现峰值和热点，例如缓存有效期限随机化、负载均衡算法（轮循环与优先级调度）、键分区算法（范围分区与哈希分区）。
- **节流**：拒绝某些计算，以防拖慢其他计算，例如服务器限速请求或去除请求路径中的缓慢服务器。
- **冗余**：剔除一次以上的相同计算并返回最快完成的计算，例如分布式系统中的备份或多面请求（hedged requests）、应对故障的冗余服务器（数据库双机热备）。
- **协同定位**：把物理上更接近的东西放到一起以降低延迟，例如CDN、全世界的多数据中心、将关联的服务器放在同一机架上。
- **更快的硬件**：又称为垂直扩展（vertical scaling），例如更快的CPU、更多的内存、更多的CPU缓存、固态硬盘、更快的网络、在内存中执行计算而不是在磁盘上计算，或者用在CPU缓存中计算代替在内存中计算。
- **更快的算法**：找到可以减少工作量的算法，例如用二分搜索代替线性搜索、用快速排序代替冒泡排序。

## 团队篇

### 创业文化

### 求职

### 招聘

### 学习

三个重要的观点：创业与人密不可分、伟大的公司是进化而来的、速读制胜。
